# Circular planar piston
# Evaluate the acoustic field generated by a circular planar piston

# Collocation ("discrete dipole") approximation of the volume integral 
# equation for 3D acoustic scattering
import os
import sys
# FIXME: figure out how to avoid this sys.path stuff
sys.path.append(os.path.join(os.path.dirname(__file__),'../../'))
import numpy as np
from piston import plane_circular_piston
from vines.geometry.geometry import generatedomain

k1 = (4225.410428500058 + 0.02498j)
pressure_surface = 4*10**6
radius = 0.005
# n_elements = 2**12
# radius = 0.02  # 7.5cm
# aperture_radius = 0.00 # 2cm
# focal_length = 0.03  # 13cm
# focus = [0., 0., 0.]
lam = 2 * np.pi / np.real(k1)

def attenuation(f0):
    alpha = 0.217 * (f0 * 1e-6)**2 
    return alpha

k1 = np.real(k1) + 1j * attenuation(1e6)

c0 = 1487.0              # wavespeed
# p0 = 1.35e4             # initial pressure amplitude
# p0 = 4.41e6
beta = 3.5e0
rho = 998

nPerLam = 5        # number of voxels per interior wavelength

res = lam / nPerLam

# Dimension of computation domain
# x_start = -0.98 * np.sqrt(focal_length**2 - radius**2) # just to the right of bowl
# x_end = 0.01
# wx = x_end - x_start
# wy = 2 * 0.83 * radius # slightly narrower than bowl
# # wy = 2 * radius # same width as bowl
# wz = wy
x_start = 0.0005
x_end = 0.06

wx = x_end - x_start
wy = 2 * radius 
wz = wy
# embed()
import time
start = time.time()
r, L, M, N = generatedomain(res, wx, wy, wz)
# Adjust r
r[:, :, :, 0]  = r[:, :, :, 0] - r[0, 0, 0, 0] + x_start
end = time.time()
print('Mesh generation time:', end-start)
# embed()
points = r.reshape(L*M*N, 3, order='F')

start = time.time()
p = plane_circular_piston(radius, k1, points.T)
p *= pressure_surface * 2j * k1
P = p.reshape(L, M, N, order='F')
end = time.time()
print('Incident field evaluation time (s):', end-start)


# Array to be populated with different harmonics evaluated on central axis
ny_centre = np.int(np.floor(M/2))
nz_centre = np.int(np.floor(N/2)) 
harmonics = np.zeros((4, L), dtype=np.complex128)

# First harmonic (i.e., incident field)
harmonics[0, :] = P[:, ny_centre, nz_centre]

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot as plt
matplotlib.rcParams.update({'font.size': 22})
# plt.rc('font', family='serif')
fig = plt.figure(figsize=(15, 5))
ax = fig.gca()
plt.imshow(np.abs(P[:, :, np.int(np.floor(N/2))].T),
           cmap=plt.cm.get_cmap('viridis'), interpolation='spline16')
plt.xlabel(r'$x$')
plt.ylabel(r'$y$')
plt.colorbar()
fig.savefig('VIE_bowl_transducer_1p5cm.png')
plt.close()
# embed()
# Generate volume potential operator for 2xk
dx = r[1, 0, 0, 0] - r[0, 0, 0, 0]
vol = (dx)**3  # voxel volume
a = (3/4 * vol / np.pi)**(1/3)  # radius of sphere of same volume

# ################# SECOND HARMONIC ########################
# # ko = 2 * k1
# ko = 2 * np.real(k1) + 1j * attenuation(2e6)
# # Create Toeplitz operator
# R0 = r[0, 0, 0, :]

# self = (1/ko**2 - 1j*a/ko) * np.exp(1j*ko*a) - 1/ko**2

# nearby_quad = 'off'
# n_quad = 10
# xG, wG = np.polynomial.legendre.leggauss(n_quad)
# XG, YG, ZG = np.meshgrid(xG, xG, xG)
# XW, YW, ZW = np.meshgrid(wG*0.5, wG*0.5, wG*0.5)

# # from operators import potential_fast
# from numba import jit, njit, prange
# @njit(parallel=True)
# def potential_fast(ko):
#     toep = np.zeros((L, M, N), dtype=np.complex128)
#     for i in prange(0, L):
#         for j in range(0, M):
#             for k in range(0, N):
#                 R1 = r[i,j,k,:]
#                 rk_to_rj = R1-R0
#                 rjk = np.linalg.norm(rk_to_rj)
#                 if nearby_quad in 'on':
#                     if rjk < 5 * dx and rjk > 1e-15:
#                         x_grid = R1[0] + dx/2 * XG
#                         y_grid = R1[1] + dx/2 * YG
#                         z_grid = R1[2] + dx/2 * ZG

#                         temp = 0.0+0.0j
#                         for iQ in range(0, n_quad):
#                             for jQ in range(0, n_quad):
#                                 for kQ in range(0, n_quad):
#                                     RQ = np.array([x_grid[iQ, jQ, kQ],
#                                          y_grid[iQ, jQ, kQ],z_grid[iQ, jQ, kQ]])

#                                     rk_to_rj = RQ - R0

#                                     rjk = np.linalg.norm(rk_to_rj)
#                                     rjk_hat = rk_to_rj / rjk
#                                     rjkrjk = np.outer(rjk_hat, rjk_hat)

#                                     Ajk = np.exp(1j * ko * rjk) / (4 * np.pi * rjk) * dx**3
#                                          # Draine & Flatau
#                                     temp = temp + Ajk * XW[iQ, jQ, kQ] * YW[iQ, jQ, kQ] * ZW[iQ, jQ, kQ]
#                         # from IPython import embed; embed()
#                         toep[i, j, k] = temp
#                     else:
#                         if np.abs(rjk) > 1e-15:
#                             toep[i, j, k] = \
#                                 np.exp(1j * ko * rjk) / (4 * np.pi * rjk) * dx**3
#                         else:
#                             toep[i, j, k] = self
#                 else:
#                     if np.abs(rjk) > 1e-15:
#                         toep[i, j, k] = \
#                             np.exp(1j * ko * rjk) / (4 * np.pi * rjk) * dx**3
#                     else:
#                         toep[i, j, k] = self
#     return toep

# start = time.time()
# toep = potential_fast(ko)
# end = time.time()
# print('Operator assembly time:', end-start)
# # toep = ko**2 * toep
# toep = toep

# start = time.time()
# from operators import circulant_embed
# circ_op = circulant_embed(toep, L, M, N)
# end = time.time()
# print('Time for circulant embedding and FFT:', end-start)

# from matvecs_acoustic import mvp_vec


# xIn = np.zeros((L, M, N), dtype=np.complex128)

# xIn = P
# xInVec = xIn.reshape((L*M*N, 1), order='F')

# idx = np.ones((L, M, N), dtype=bool)
# mvp = lambda x: mvp_vec(x, circ_op, idx, Mr)

# # Voxel permittivities
# Mr = np.ones((L, M, N), dtype=np.complex128)

# start = time.time()
# xOut = mvp(2 * beta * np.real(k1)**2 / (rho * c0**2) * xInVec * xInVec)
# end = time.time()
# print('Time for MVP:', end-start)
# # from IPython import embed; embed()
# P2 = xOut.reshape(L, M, N, order='F')

# #-------------- Third harmonic ----------------#
# # Create volume potential to evaluate next harmonic
# # ko = 3 * k1
# ko = 3 * np.real(k1) + 1j * attenuation(3e6)
# start = time.time()
# toep = potential_fast(ko)
# end = time.time()
# print('Operator assembly time:', end-start)

# start = time.time()
# from operators import circulant_embed
# circ_op = circulant_embed(toep, L, M, N)
# end = time.time()
# print('Time for circulant embedding and FFT:', end-start)

# xIn = np.zeros((L, M, N), dtype=np.complex128)

# f_rhs = P * P2
# xInVec = f_rhs.reshape((L*M*N, 1), order='F')

# start = time.time()
# xOut = mvp(9 * beta * np.real(k1)**2 / (rho * c0**2) * xInVec)
# end = time.time()
# print('Time for MVP:', end-start)
# # from IPython import embed; embed()
# P3 = xOut.reshape(L, M, N, order='F')

# total = P + P2 + P3

# # Plot harmonics along central axis
# x_line = (r[:, ny_centre, nz_centre, 0]) * 100
# fig = plt.figure(figsize=(14, 8))
# ax = fig.gca()
# plt.plot(x_line, np.abs(P[:, ny_centre, nz_centre])/1e6,'k-', linewidth=2)
# plt.plot(x_line, np.abs(P2[:, ny_centre, nz_centre])/1e6,'r-', linewidth=2)
# plt.plot(x_line, np.abs(P3[:, ny_centre, nz_centre])/1e6,'b-', linewidth=2)
# plt.plot(x_line, np.abs(total[:, ny_centre, nz_centre])/1e6,'g-', linewidth=2)
# plt.grid(True)
# # plt.xlim([1, 7])
# # plt.ylim([0, 9])
# plt.xlabel(r'Axial distance (cm)')
# plt.ylabel(r'Pressure (MPa)')
# fig.savefig('images/VIE_piston_harms_axis.png')
# plt.close()
# exit(1)

# # Right-hand side for computation of next harmonic
# f_rhs = P2 * P2 + 2 * P * P3
# # Plot  f_rhs
# rel_p = np.log10(np.abs(f_rhs) / np.max(np.abs(f_rhs)))
# import matplotlib
# matplotlib.use('Agg')
# import matplotlib.pyplot as plt
# matplotlib.rcParams.update({'font.size': 26})
# # matplotlib.rc('font',**{'family':'serif','serif':['Palatino']})
# # plt.rc('text', usetex=True)
# fig = plt.figure(figsize=(14, 8))
# ax = fig.gca()
# CS = plt.contourf(rel_p[:, :, np.int(np.round(N/2))].T,
#              extent=[x_start, x_end, -wy/2, wy/2],
#              levels=[-4, -3.5, -2.5, -2.0, -1.5, -1, -0.5, 0],
#              cmap=plt.cm.viridis,
#              extend='both')
# cbar = plt.colorbar(CS)
# CS.cmap.set_under('black')
# CS.changed()
# cbar.ax.set_ylabel('log$_{10}(|f_4|$/max$|f_4|)$')

# # labels
# plt.ylabel('$y$ (cm)')
# plt.xlabel('$z$ (cm)')
# fig.savefig('images/test_p4.png', dpi=300)
# plt.close()


# ################### P4 computation ######################
# # Create volume potential to evaluate next harmonic
# ko = 4 * k1
# start = time.time()
# toep = potential_fast(ko)
# end = time.time()
# print('Operator assembly time:', end-start)

# start = time.time()
# from operators import circulant_embed
# circ_op = circulant_embed(toep, L, M, N)
# end = time.time()
# print('Time for circulant embedding and FFT:', end-start)


# # For chopping of domain where f_rhs below a certain size
# rel_p = np.log10(np.abs(f_rhs)/np.max(np.abs(f_rhs)))
# # TOL = np.array([-0.5, -1, -1.5, -2, -2.5, -3, -3.5, -4])
# TOL = np.array([-0.5, -0.75, -1, -1.25, -1.5, -1.75, -2, -2.25, -2.5, -2.75,
#                 -3, -3.25, -3.5, -3.75, -4])
# line_harmonic = np.zeros((TOL.shape[0], L), dtype=np.complex128) 
# xMinVals = np.zeros(TOL.shape[0])
# xMaxVals = np.zeros(TOL.shape[0])
# yMinVals = np.zeros(TOL.shape[0])
# yMaxVals = np.zeros(TOL.shape[0])

# for i_tol in range(TOL.shape[0]):
#     where_bigger = np.argwhere(rel_p > TOL[i_tol])
#     min_x_idx = np.min(where_bigger[:, 0])
#     max_x_idx = np.max(where_bigger[:, 0])
#     min_y_idx = np.min(where_bigger[:, 1])
#     max_y_idx = np.max(where_bigger[:, 1])
#     min_z_idx = np.min(where_bigger[:, 2])
#     max_z_idx = np.max(where_bigger[:, 2])

#     xMinVals[i_tol] = r[min_x_idx,0,0,0] 
#     xMaxVals[i_tol] = r[max_x_idx,0,0,0] 
#     yMinVals[i_tol] = r[0,min_y_idx,0,1] 
#     yMaxVals[i_tol] = r[0,max_y_idx,0,1] 

#     print('Size x = ', (max_x_idx-min_x_idx)*dx)
#     print('Size y,z = ', (max_y_idx-min_y_idx)*dx)

#     P_trim = np.zeros((L, M, N), dtype=np.complex128)
#     P_trim[min_x_idx:max_x_idx, min_y_idx:max_y_idx, min_z_idx:max_z_idx] = \
#         f_rhs[min_x_idx:max_x_idx, min_y_idx:max_y_idx, min_z_idx:max_z_idx]
    
#     xIn = P_trim
#     xInVec = xIn.reshape((L*M*N, 1), order='F')

#     idx = np.ones((L, M, N), dtype=bool)
#     mvp = lambda x: mvp_vec(x, circ_op, idx, Mr)

#     # Voxel permittivities
#     Mr = np.ones((L, M, N), dtype=np.complex128)

#     start = time.time()
#     xOut = mvp(8 * beta * np.real(k1)**2 / (rho * c0**2) * xInVec)
#     end = time.time()
#     print('Time for MVP:', end-start)
#     # from IPython import embed; embed()
#     field = xOut.reshape(L, M, N, order='F')
#     line = field[:, ny_centre, nz_centre]
#     line_harmonic[i_tol, :] = line

# # filename = 'results/axial_x60lam_yz20lam_nPerLam10.npy'
# # filename = 'results/axial_x40lam_vary_yz30lam_nPerLam20.npy'

# import pickle
# with open('results/axial_p4_vary_domain_size_log_fine_20vpl1.pickle', 'wb') as f:
#     pickle.dump([line_harmonic, xMinVals, xMaxVals, yMinVals, yMaxVals], f)
# # with open('results/axial_vary_domain_length_10vpl.pickle', 'wb') as f:
# #     pickle.dump([line_harmonic, X_SUB], f)

# exit(1)

# filename = 'results/axial_vary_domain_size_absolute_5vpl.npy'
# np.save(filename, line_harmonic)


# #-------------- Next harmonic ----------------#
# # Create volume potential to evaluate next harmonic
# ko = 4 * k1
# start = time.time()
# toep = potential_fast(ko)
# end = time.time()
# print('Operator assembly time:', end-start)

# start = time.time()
# from operators import circulant_embed
# circ_op = circulant_embed(toep, L, M, N)
# end = time.time()
# print('Time for circulant embedding and FFT:', end-start)

# xIn = np.zeros((L, M, N), dtype=np.complex128)

# xIn = field3
# xInVec3 = xIn.reshape((L*M*N, 1), order='F')

# start = time.time()
# xOut = mvp(8 * beta * np.real(k1)**2 / (rho * c0**2) * \
#         (xInVec2 * xInVec2 + 2 * xInVec * xInVec3))
# end = time.time()
# print('Time for MVP:', end-start)
# # from IPython import embed; embed()
# field4 = xOut.reshape(L, M, N, order='F')

# # Third harmonic
# harmonics[3, :] = field4[:, ny_centre, nz_centre]

# fig = plt.figure(figsize=(10, 10))
# ax = fig.gca()
# plt.imshow(np.abs(field4[:, :, np.int(np.floor(N/2))].T),
#            cmap=plt.cm.get_cmap('RdBu_r'), interpolation='spline16')
# plt.xlabel(r'$x$')
# plt.ylabel(r'$y$')
# plt.colorbar()
# fig.savefig('images/VIE_bowl_transducer_harm4_1p5cm.png')
# plt.close()

# # Plot harmonics along central axis
# x_line = (r[:, ny_centre, nz_centre, 0] + 0.05) * 100
# fig = plt.figure(figsize=(14, 8))
# ax = fig.gca()
# plt.plot(x_line, np.abs(harmonics[0,:])/1e6,'k-', linewidth=2)
# plt.plot(x_line, np.abs(harmonics[1,:])/1e6,'r-', linewidth=2)
# plt.plot(x_line, np.abs(harmonics[2,:])/1e6,'b-', linewidth=2)
# plt.plot(x_line, np.abs(harmonics[3,:])/1e6,'g-', linewidth=2)
# plt.grid(True)
# plt.xlim([1, 7])
# plt.ylim([0, 9])
# plt.xlabel(r'Axial distance (cm)')
# plt.ylabel(r'Pressure (MPa)')
# fig.savefig('images/VIE_harms_axis.png')
# plt.close()

# # np.savez('results/VIE_harms_1p5cm.npy', harms=harmonics, x_line=x_line)
# np.save('results/VIE_harms_1p5cm.npy', np.array([harmonics, x_line]))


# embed()